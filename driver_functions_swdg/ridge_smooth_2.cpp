//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// 
// ridge_smooth_2.cpp
// 
// Simple driver which takes the LH, Relief and CHT files generated by LH_Driver
// and smooths the data and generates E* R* data in 2 files, one called E_Star_sc<critical slope>.txt
// and another called R_Star_sc<critical slope>.txt Thes files have no headers and each contain a single 
// column with the same data.
//
// This driver calculates the E* R* values on the raw data and then smooths it.
//
// Input argument is the critical slope value as a floating point number eg 0.8 
//
// Paths and filenames must be ,anually set by the user.
//
// Stuart W.D. Grieve
// University of Edinburgh
//
//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#include <iostream>
#include <string>
#include <vector>
#include <fstream>
#include "../LSDStatsTools.hpp"
#include "../LSDRaster.hpp"
#include "../LSDIndexRaster.hpp"
#include "../LSDFlowInfo.hpp"
#include "../LSDChannel.hpp"
#include "../LSDJunctionNetwork.hpp"
#include "../LSDIndexChannel.hpp"
#include "../LSDMostLikelyPartitionsFinder.hpp"
#include "../LSDBasin.hpp"
#include "../LSDShapeTools.hpp"

int main (int nNumberofArgs,char *argv[])
{
  
  //Test for correct input arguments
	if (nNumberofArgs!=2)
	{ 
    cout << "Fire in a critical slope here." << endl;
		exit(EXIT_FAILURE);
	}
  
  //load input argument
  float S_c = atof(argv[1]);  
  
  string path = "/home/s0675405/DataStore/CR/";

  //load LH
  LSDRaster LH((path+"CR2_HFR_LH"), "flt"); 
  
  //load R
  LSDRaster R((path+"CR2_Relief"), "flt");
  
  //load CHT
  LSDRaster CHT((path+"CR2_CHT"), "flt");
  
  
  float ndv = LH.get_NoDataValue();
  int nrows = LH.get_NRows();
  int ncols = LH.get_NCols();
  
  Array2D<float> e_s(nrows,ncols,ndv);
  Array2D<float> r_s(nrows,ncols,ndv);
  
  
  for (int i=0; i<nrows; ++i){
	  for (int j=0; j<ncols; ++j){
	  	if (CHT.get_data_element(i,j) != ndv && LH.get_data_element(i,j) != ndv && R.get_data_element(i,j) != ndv){
	  	
	  	  e_s[i][j] = (2.0 * abs(CHT.get_data_element(i,j))*LH.get_data_element(i,j))/S_c;  
	  	  r_s[i][j] = R.get_data_element(i,j)/(LH.get_data_element(i,j)*S_c);
	  	}
	  }
	}

  
  //cast arrays into lsdrasters
  LSDRaster EStar = LH.LSDRasterTemplate(e_s);
  LSDRaster RStar = LH.LSDRasterTemplate(r_s);
  
  
  //run neighbourhood_statistics_spatial_average
  LSDRaster Smoothed_EStar = EStar.neighbourhood_statistics_spatial_average(25.0, 1);
  LSDRaster Smoothed_RStar = RStar.neighbourhood_statistics_spatial_average(25.0, 1);
   
  stringstream ss;
  ss << path << "E_Star_sc_" << S_c <<".txt";                
  Smoothed_EStar.FlattenToFile(ss.str());
  
  stringstream ss2;
  ss2 << path << "R_Star_sc_" << S_c <<".txt";                
  Smoothed_RStar.FlattenToFile(ss2.str());
   

}
