//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// 
// E_STAR_R_STAR.cpp
// 
// Driver to produce E*R* data from a series of raster files generated using LH_Driver.cpp
//
// Requires 4 input raster files located in the user supplied directory:
// 
// <prefix>_Relief.flt 
// <prefix>_HFR_LH.flt  - Hillslope Length
// <prefix>_Slope.flt
// <prefix>_CHT.flt - Hilltop curvature
//
// And 5 input arguments:
//
// path - the path to the data files and where the outputs will be stored, must include trailing slash
// prefix - the filename prefix of the input raster files, without the underscore
// Minimum patch area - The minimum area in pixels of a patch that will be considered valid
// Minimum number of basin points - The minimum number of data points needed for a basin average value
// Basin Order - The stream order of basins to be averaged over
//
// An example of running this driver would be:
//
// ./E_Star_R_Star.out /homes/s0675405/Data/ OR 100 100 2
//
// Outputs 2 csv files and a raster of hilltop patches, <prefix>_Patches.flt,
// into the user supplied path. The csv files contain the data averaged over hilltop 
// patches and raw data. Information of the format of these output files can be found at
// [URL].
//
// These data files can be processed using the python scripts located at https://github.com/sgrieve/GeneralAnalysis
//
// Stuart W.D. Grieve, 10/6/15
// University of Edinburgh
//
//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
#include <iostream>
#include <string>
#include <vector>
#include <fstream>
#include "../LSDStatsTools.hpp"
#include "../LSDRaster.hpp"
#include "../LSDIndexRaster.hpp"
#include "../LSDFlowInfo.hpp"
#include "../LSDChannel.hpp"
#include "../LSDJunctionNetwork.hpp"
#include "../LSDIndexChannel.hpp"
#include "../LSDMostLikelyPartitionsFinder.hpp"
#include "../LSDBasin.hpp"
#include "../LSDShapeTools.hpp"

int main (int nNumberofArgs,char *argv[])
{
 
  //Test for correct input arguments
  if (nNumberofArgs!=6)
  {
    cout << "FATAL ERROR: wrong number of inputs. The program needs the path (with trailing slash), the filename prefix, the minimum patch area in pixels and the basin order." << endl; 
    exit(EXIT_FAILURE);
  }
  
  //load input arguments
  string path = argv[1];
  string prefix = argv[2];
  int MinimumPatchArea = atoi(argv[3]);  //Minium area of a hilltop patch. In pixels.
  int MinBasinSize = atoi(argv[4]); //Minium number of data points in a basin.
  int BasinOrder = atoi(argv[5]);
    
  cout << "Filling DEM and generating the junction network." << endl;
  
  //set boundary conditions
  vector<string> BoundaryConditions(4, "No Flux");
  
  //load dem
  LSDRaster DEM((path+prefix+"_DEM"), "flt");
  
  //Fill 
  float MinSlope = 0.0001;
  LSDRaster FilledDEM = DEM.fill(MinSlope);
  
  // get a flow info object
  LSDFlowInfo FlowInfo(BoundaryConditions,FilledDEM);
  
  //get junction network from channel heads
  vector<int> sources = FlowInfo.Ingest_Channel_Heads((path+prefix+"_DEM_CH"), "flt");
  cout << "ingested" << endl; 
  LSDJunctionNetwork JunctionNetwork(sources, FlowInfo);
  cout << "junctions" << endl;
  //Extract basins based on input stream order
  vector< int > basin_junctions = JunctionNetwork.ExtractBasinJunctionOrder(BasinOrder, FlowInfo);
  
  cout << "Loading raster datasets" << endl;

  //Load data generated by LH_Driver.cpp

  //load hillslope length data
  LSDRaster lh((path+prefix+"_HFR_LH"), "flt"); 
  
  //load Relief
  LSDRaster relief((path+prefix+"_Relief"), "flt");
   
  //load hilltop curvature
  LSDRaster CHT((path+prefix+"_CHT"), "flt");
  
  //load slope
  LSDRaster Slope((path+prefix+"_Slope"), "flt");
  
  //create hilltop slope raster - uses hilltop curvature sampling routine, but samples slope along the hilltop instead.
  LSDRaster HilltopSlope = FilledDEM.get_hilltop_curvature(Slope, CHT);
    
  //Filter Relief and LH data to remove any values < 2, as in Grieve et al (2015)
  LSDRaster LH = lh.RemoveBelow(2.0);
  LSDRaster Relief = relief.RemoveBelow(2.0);  
    
  cout << "Generating contiguous hilltop patches" << endl;
   
  //Run the hilltop patch algorithm   
  LSDIndexRaster HilltopPatches = CHT.CreateHilltopPatches(MinimumPatchArea);
  //LSDIndexRaster HilltopPatches((path+prefix+"_Patches"), "flt");
        
  float ndv = LH.get_NoDataValue();
  int nrows = LH.get_NRows();
  int ncols = LH.get_NCols();

  //set up some variables to store values as we run through the patches
  int PatchID;
  vector<float> lh_data;
  vector<float> cht_data;
  vector<float> r_data;
  vector<float> s_data;

  //vectors to store the stats for each patch
  vector<float> Final_ID;

  vector<float> lh_means;
  vector<float> lh_medians;
  vector<float> lh_std_devs;
  vector<float> lh_std_errs;
  
  vector<float> cht_means;
  vector<float> cht_medians;
  vector<float> cht_std_devs;
  vector<float> cht_std_errs;
  
  vector<float> r_means;
  vector<float> r_medians;
  vector<float> r_std_devs;
  vector<float> r_std_errs;
  
  vector<float> s_means;
  vector<float> s_medians;
  vector<float> s_std_devs;
  vector<float> s_std_errs;
  
  vector<int> Sizes;
   
  //Get vector of unique segment indexes
  vector<int> PatchIndex = Unique(HilltopPatches.get_RasterData(), ndv);

  cout << "Calculating patch statistics." << endl;

  //for each patch in the landscape get the mean values
  for (int q = 0; q < int(PatchIndex.size()); ++q){
  
    PatchID = PatchIndex[q];
    
    //empty data vectors ready for next patch data to be added  
    lh_data.clear();
    cht_data.clear();
    r_data.clear();
    s_data.clear();
    
    int patchsize = 0;
    
    for (int i=0; i<nrows; ++i){
      for (int j=0; j<ncols; ++j){
      
        if (HilltopPatches.get_data_element(i,j) == PatchID){
           
          //make sure we have valid data for each of our arrays
          if (CHT.get_data_element(i,j) != ndv && LH.get_data_element(i,j) != ndv && Relief.get_data_element(i,j) != ndv && Slope.get_data_element(i,j) != ndv){
              if (Slope.get_data_element(i,j) <= 0.4 ){
                lh_data.push_back(LH.get_data_element(i,j));
                r_data.push_back(Relief.get_data_element(i,j));
                cht_data.push_back(CHT.get_data_element(i,j));
                s_data.push_back(Slope.get_data_element(i,j));
                ++patchsize;
              }
            }
          }
        }
      }
    
    //calculate the mean, median, stddev and std err values for each value in the current segment
  
    //avoid calculations on empty vectors
    if (!lh_data.empty() || !r_data.empty() || !cht_data.empty() || !s_data.empty()){
      
      //Hillslope Length
      float lh_mean;
      float lh_median;
      float lh_upper;
      float lh_lower;
      float lh_max;
      float lh_std_dev;
      float lh_std_err;
      
      get_distribution_stats(lh_data, lh_mean, lh_median, lh_upper, lh_lower, lh_max);
      lh_std_dev = get_standard_deviation(lh_data, lh_mean);
      lh_std_err = get_standard_error(lh_data, lh_std_dev);
      
      //Hilltop Curvature
      float cht_mean;
      float cht_median;
      float cht_upper;
      float cht_lower;
      float cht_max;
      float cht_std_dev;
      float cht_std_err;
      
      get_distribution_stats(cht_data, cht_mean, cht_median, cht_upper, cht_lower, cht_max);
      cht_std_dev = get_standard_deviation(cht_data, cht_mean);
      cht_std_err = get_standard_error(cht_data, cht_std_dev);
      
      //Relief
      float r_mean;
      float r_median;
      float r_upper;
      float r_lower;
      float r_max;
      float r_std_dev;
      float r_std_err;
      
      get_distribution_stats(r_data, r_mean, r_median, r_upper, r_lower, r_max);
      r_std_dev = get_standard_deviation(r_data, r_mean);
      r_std_err = get_standard_error(r_data, r_std_dev);
      
      //Hilltop slope
      float s_mean;
      float s_median;
      float s_upper;
      float s_lower;
      float s_max;
      float s_std_dev;
      float s_std_err;
      
      get_distribution_stats(s_data, s_mean, s_median, s_upper, s_lower, s_max);
      s_std_dev = get_standard_deviation(s_data, s_mean);
      s_std_err = get_standard_error(s_data, s_std_dev);
             
      //put patch stats into series of vectors ready to be written to file
      Final_ID.push_back(PatchID);
      
      lh_means.push_back(lh_mean);
      lh_medians.push_back(lh_median);
      lh_std_devs.push_back(lh_std_dev);
      lh_std_errs.push_back(lh_std_err);    
      
      cht_means.push_back(cht_mean);
      cht_medians.push_back(cht_median);
      cht_std_devs.push_back(cht_std_dev);
      cht_std_errs.push_back(cht_std_err);
      
      r_means.push_back(r_mean);
      r_medians.push_back(r_median);
      r_std_devs.push_back(r_std_dev);
      r_std_errs.push_back(r_std_err);
      
      s_means.push_back(s_mean);
      s_medians.push_back(s_median);
      s_std_devs.push_back(s_std_dev);
      s_std_errs.push_back(s_std_err);
      
      Sizes.push_back(patchsize);
      
    }
  }
  
  cout << "Writing patch data to file" << endl;
    
  //write the patch data  
  ofstream WritePatchData;
  stringstream ss;
  ss << path << prefix << "_E_R_Star_Patch_Data.csv";
  WritePatchData.open(ss.str().c_str());

  //write the header file
  WritePatchData << "Final_ID,lh_means,lh_medians,lh_std_devs,lh_std_errs,cht_means,cht_medians,cht_std_devs,cht_std_errs,r_means,r_medians,r_std_devs,r_std_errs,s_means,s_medians,s_std_devs,s_std_errs,size" << endl;
  
  for (int w = 0; w < int(Final_ID.size());++w){
    //break this over a few lines for clarity
    WritePatchData << Final_ID[w] << "," << lh_means[w] << "," << lh_medians[w] << "," << lh_std_devs[w] << "," << lh_std_errs[w] << "," << cht_means[w] << "," << cht_medians[w] << "," << cht_std_devs[w] << "," << cht_std_errs[w] << "," << r_means[w] << "," << r_medians[w] << "," << r_std_devs[w] << "," << r_std_errs[w] << "," << s_means[w] << "," << s_medians[w] << "," << s_std_devs[w] << "," << s_std_errs[w] << "," << Sizes[w] << endl;
   
  }
  
  WritePatchData.close();

  //Now generate a raw data file so that the raw data can be plotted along with the segments
  
  cout << "Writing raw data to file" << endl;
  
  //write the raw data  
  ofstream WriteRawData;
  stringstream ss2;
  ss2 << path << prefix << "_E_R_Star_Raw_Data.csv";
  WriteRawData.open(ss2.str().c_str());
    
  //write the header
  WriteRawData << "i,j,LH,CHT,Relief,Slope" << endl;  
    
   for (int i=0; i<nrows; ++i){
      for (int j=0; j<ncols; ++j){
      
        if (CHT.get_data_element(i,j) != ndv && LH.get_data_element(i,j) != ndv && Relief.get_data_element(i,j) != ndv && Slope.get_data_element(i,j) != ndv && Slope.get_data_element(i,j) <= 0.4){
        
          WriteRawData << i << "," << j << "," << LH.get_data_element(i,j) << "," << CHT.get_data_element(i,j) << "," << Relief.get_data_element(i,j) << "," << Slope.get_data_element(i,j) << endl;
        
        }
      }
    }
    
  WriteRawData.close();
  
  //Now we want to remove all datapoints which have a hilltop slope greater than 0.4
  //prior to creating the basin objects
  
  Array2D<float> newLH = LH.get_RasterData();
  Array2D<float> newR = Relief.get_RasterData();
  Array2D<float> newS = HilltopSlope.get_RasterData();
  Array2D<float> newCHT = CHT.get_RasterData();
  
  
  for (int i=0; i<nrows; ++i){
    for (int j=0; j<ncols; ++j){
      if (Slope.get_data_element(i,j) > 0.4 ){
        newLH[i][j] = ndv; 
        newR[i][j] = ndv; 
        newS[i][j] = ndv; 
        newCHT[i][j] = ndv;  
      } 
    }   
  }
  
  //generate LSDRasters from our cleaned arrays
  LSDRaster NewLH = LH.LSDRasterTemplate(newLH);
  LSDRaster NewR = Relief.LSDRasterTemplate(newR);
  LSDRaster NewHilltopSlope = HilltopSlope.LSDRasterTemplate(newS);
  LSDRaster NewCHT = CHT.LSDRasterTemplate(newCHT);    
  
  //Now generate basin average data for the basins of the user supplied order
  
  cout << "Generating basin average data using LSDBasin" << endl;
  
  //create lsdbasin objects in a loop over each junction number
  vector< LSDBasin > Basins;
  
   //loop over each basin, generating an LSDBasin object which contains that basin's measurements
  for (int w = 0; w < int(basin_junctions.size()); ++w){
                                    
    LSDBasin Basin(basin_junctions[w], FlowInfo, JunctionNetwork);
    Basin.set_HillslopeLength_HFR(FlowInfo, NewLH);
    Basin.set_SlopeMean(FlowInfo, NewHilltopSlope);   
    Basin.set_ReliefMean(FlowInfo, NewR);
    Basin.set_CHTMean(FlowInfo, NewCHT);
    Basin.set_HilltopPx(FlowInfo,NewCHT);
  
    Basins.push_back(Basin);
    
  }
  
  cout << "Writing basin average data to file" << endl;
  
  //write the basin data  
  ofstream WriteBasinData;                 
  stringstream ss3;
  ss3 << path << prefix << "_E_R_Star_Basin_" << BasinOrder << "_Data.csv";
  WriteBasinData.open(ss3.str().c_str());
    
  //write the header
  WriteBasinData << "Basin_ID,LH_mean,CHT_mean,Relief_mean,Slope_mean,LH_median,CHT_median,Relief_median,Slope_median,LH_StdDev,CHT_StdDev,Relief_StdDev,Slope_StdDev,LH_StdErr,CHT_StdErr,Relief_StdErr,Slope_StdErr,Area,Count" << endl;
  
  //write all data to the opened file, ensuring that there are data points to be written in each basin
  for (int q = 0; q < int(Basins.size()); ++q){
    // only work where we have data points
    if (Basins[q].CalculateNumDataPoints(FlowInfo, NewLH) >= MinBasinSize && Basins[q].CalculateNumDataPoints(FlowInfo, NewCHT) >= MinBasinSize && Basins[q].CalculateNumDataPoints(FlowInfo, NewR) >= MinBasinSize && Basins[q].CalculateNumDataPoints(FlowInfo, NewHilltopSlope) >= MinBasinSize){
      
      WriteBasinData << Basins[q].get_Junction() << "," << Basins[q].get_HillslopeLength_HFR() << ",";
      WriteBasinData << Basins[q].get_CHTMean() << "," << Basins[q].get_ReliefMean() << ",";
      WriteBasinData << Basins[q].get_SlopeMean() << "," << Basins[q].CalculateBasinMedian(FlowInfo,NewLH) << ",";
      WriteBasinData << Basins[q].CalculateBasinMedian(FlowInfo,NewCHT) << ",";
      WriteBasinData << Basins[q].CalculateBasinMedian(FlowInfo,NewR) << "," << Basins[q].CalculateBasinMedian(FlowInfo,NewHilltopSlope) << ",";
      WriteBasinData << Basins[q].CalculateBasinStdDev(FlowInfo, NewLH) << "," << Basins[q].CalculateBasinStdDev(FlowInfo, NewCHT) << ",";
      WriteBasinData << Basins[q].CalculateBasinStdDev(FlowInfo, NewR) << "," << Basins[q].CalculateBasinStdDev(FlowInfo, NewHilltopSlope) << ","; 
      WriteBasinData << Basins[q].CalculateBasinStdError(FlowInfo, NewLH) << "," << Basins[q].CalculateBasinStdError(FlowInfo, NewCHT) << ",";
      WriteBasinData << Basins[q].CalculateBasinStdError(FlowInfo, NewR) << "," << Basins[q].CalculateBasinStdError(FlowInfo, NewHilltopSlope) << ",";
      WriteBasinData << Basins[q].get_Area() << "," << Basins[q].get_HilltopPx() << endl;
   
    }
  }
  
  WriteBasinData.close();
  
  //write the Patch raster data
  HilltopPatches.write_raster((path+prefix+"_Patches"),"flt");
  
}
