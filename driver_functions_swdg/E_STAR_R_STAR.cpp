//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// 
// E_STAR_R_STAR.cpp
// 
// Driver to produce E*R* data from a series of raster files generated using LH_Driver.cpp
//
// Requires 4 input raster files located in the user supplied directory:
// 
// <prefix>_Relief.flt 
// <prefix>_HFR_LH.flt  - Hillslope Length
// <prefix>_Slope.flt
// <prefix>_CHT.flt - Hilltop curvature
//
// And 3 input arguments:
//
// path - the path to the data files and where the outputs will be stored, must include trailing slash
// prefix - the filename prefix of the input raster files, without the underscore
// Minimum patch area - The minimum area in pixels of a patch that will be considered valid
//
// An example of running this driver would be:
//
// ./E_Star_R_Star.out /homes/s0675405/Data/ OR 20
//
// Outputs 2 csv files and a raster of hilltop patches, <prefix>_Patches.flt,
// into the user supplied path. The csv files contain the data averaged over hilltop 
// patches and raw data. Information of the format of these output files can be found at
// [URL].
//
// These data files can be processed using the python scripts located at [URL]
//
// ONE THING TO CONSIDER IS WHETHER A PIXEL WITH A SLOPE > 0.4 SHOULD BE INCLUDED IN THE AVERAGES
// FOR A PATCH. CURRENTLY WE GET THE MEAN PATCH GRADIENT AND WOULD FILTER BASED ON THAT BUT IT MIGHT 
// BE WORTH EXPLORING THE DIFFERENCES IN RESULTS THAT EXCLUDING ALL PX WITH A SLOPE ABOVE THE THRESHOLD 
// FROM THE AVERAGING WILL HAVE ON THE RESULTS.
//
// ALSO SHOULD LOOK INTO AN OPTIONAL EXTRA PARAM TO ALLOW HURST ET AL 2013 DBPR FILTERING TO BE PERFORMED.
// NEED TO THINK ABOUT HOW TO DO THIS IN A USER FRIENDLY WAY THOUGH.   
//
// Stuart W.D. Grieve, 10/6/15
// University of Edinburgh
//
//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
#include <iostream>
#include <string>
#include <vector>
#include <fstream>
#include "../LSDStatsTools.hpp"
#include "../LSDRaster.hpp"
#include "../LSDIndexRaster.hpp"
#include "../LSDFlowInfo.hpp"
#include "../LSDChannel.hpp"
#include "../LSDJunctionNetwork.hpp"
#include "../LSDIndexChannel.hpp"
#include "../LSDMostLikelyPartitionsFinder.hpp"
#include "../LSDBasin.hpp"
#include "../LSDShapeTools.hpp"

int main (int nNumberofArgs,char *argv[])
{
  
  //Test for correct input arguments
	if (nNumberofArgs!=5)
	{
		cout << "FATAL ERROR: wrong number of inputs. The program needs the path (with trailing slash), the filename prefix, the minimum patch area in pixels and the basin order." << endl; 
		exit(EXIT_FAILURE);
	}
  
  //load input arguments
  string path = argv[1];
	string prefix = argv[2];
  int MinimumPatchArea  = atoi(argv[3]);  //Minium area of a hilltop patch. In pixels.
  int BasinOrder = atoi(argv[4]);
    
  cout << "Filling DEM and generating the junction network." << endl;
  
  //set boundary conditions
  vector<string> BoundaryConditions(4, "No Flux");
  
  //load dem
  LSDRaster DEM((path+prefix+"_DEM"), "flt");  
  
  //Fill 
  float MinSlope = 0.0001;
  LSDRaster FilledDEM = DEM.fill(MinSlope);
  
  // get a flow info object
	LSDFlowInfo FlowInfo(BoundaryConditions,FilledDEM);
  
  //get junction network from channel heads
  vector<int> sources = FlowInfo.Ingest_Channel_Heads((path+prefix+"_DEM_CH"), "flt"); 
  LSDJunctionNetwork JunctionNetwork(sources, FlowInfo);    

  //Extract basins based on input stream order
  vector< int > basin_junctions = JunctionNetwork.ExtractBasinJunctionOrder(BasinOrder, FlowInfo);
  
  cout << "Loading raster datasets" << endl;

  //Load data generated by LH_Driver.cpp

  //load hillslope length data
  LSDRaster lh((path+prefix+"_HFR_LH"), "flt"); 
  
  //load Relief
  LSDRaster relief((path+prefix+"_Relief"), "flt");
   
  //load hilltop curvature
  LSDRaster CHT((path+prefix+"_CHT"), "flt");
  
  //load slope
  LSDRaster Slope((path+prefix+"_Slope"), "flt");
  
  //create hilltop slope raster - uses hilltop curvature sampling routine, but samples slope along the hilltop instead.
  LSDRaster HilltopSlope = FilledDEM.get_hilltop_curvature(Slope, CHT);
    
  //Filter Relief and LH data to remove any values < 2, as in Grieve et al (2015)
  LSDRaster LH = lh.RemoveBelow(2.0);
  LSDRaster Relief = relief.RemoveBelow(2.0);  
    
  cout << "Generating contiguous hilltop patches" << endl;
   
  //Run the hilltop patch algorithm
  LSDIndexRaster HilltopPatches = CHT.CreateHilltopPatches(MinimumPatchArea);
        
  float ndv = LH.get_NoDataValue();
  int nrows = LH.get_NRows();
  int ncols = LH.get_NCols();

  //set up some variables to store values as we run through the patches
  int PatchID;
  vector<float> lh_data;
  vector<float> cht_data;
  vector<float> r_data;
  vector<float> s_data;

  //vectors to store the stats for each patch
  vector<float> Final_ID;

  vector<float> lh_means;
  vector<float> lh_medians;
  vector<float> lh_std_devs;
  vector<float> lh_std_errs;    
  
  vector<float> cht_means;
  vector<float> cht_medians;
  vector<float> cht_std_devs;
  vector<float> cht_std_errs;    
  
  vector<float> r_means;
  vector<float> r_medians;
  vector<float> r_std_devs;
  vector<float> r_std_errs;    
  
  vector<float> s_means;
  vector<float> s_medians;
  vector<float> s_std_devs;
  vector<float> s_std_errs;
   
  //Get vector of unique segment indexes
  vector<int> PatchIndex = Unique(HilltopPatches.get_RasterData(), ndv);

  cout << "Calculating patch statistics." << endl;

  //for each patch in the landscape get the mean values
  for (int q = 0; q < int(PatchIndex.size()); ++q){
  
    PatchID = PatchIndex[q];
    
    //empty data vectors ready for next patch data to be added  
    lh_data.clear();
    cht_data.clear();
    r_data.clear();
    s_data.clear();
    
    for (int i=0; i<nrows; ++i){
  	  for (int j=0; j<ncols; ++j){
  	  
        if (HilltopPatches.get_data_element(i,j) == PatchID){
           
          //make sure we have valid data for each of our arrays
        	if (CHT.get_data_element(i,j) != ndv && LH.get_data_element(i,j) != ndv && Relief.get_data_element(i,j) != ndv && Slope.get_data_element(i,j) != ndv){
        	            	           	
              lh_data.push_back(LH.get_data_element(i,j));
              r_data.push_back(Relief.get_data_element(i,j));
              cht_data.push_back(CHT.get_data_element(i,j));
              s_data.push_back(Slope.get_data_element(i,j));              
              
            }
          }
        }
      }
  	
    //calculate the mean, median, stddev and std err values for each value in the current segment
  
    //avoid calculations on empty vectors
    if (!lh_data.empty() || !r_data.empty() || !cht_data.empty() || !s_data.empty()){
      
      //Hillslope Length
      float lh_mean;
      float lh_median;
      float lh_upper;
      float lh_lower;
      float lh_max;
      float lh_std_dev;
      float lh_std_err;
      
      get_distribution_stats(lh_data, lh_mean, lh_median, lh_upper, lh_lower, lh_max);
      lh_std_dev = get_standard_deviation(lh_data, lh_mean);
      lh_std_err = get_standard_error(lh_data, lh_std_dev);
      
      //Hilltop Curvature
      float cht_mean;
      float cht_median;
      float cht_upper;
      float cht_lower;
      float cht_max;
      float cht_std_dev;
      float cht_std_err;
      
      get_distribution_stats(cht_data, cht_mean, cht_median, cht_upper, cht_lower, cht_max);
      cht_std_dev = get_standard_deviation(cht_data, cht_mean);
      cht_std_err = get_standard_error(cht_data, cht_std_dev);
      
      //Relief
      float r_mean;
      float r_median;
      float r_upper;
      float r_lower;
      float r_max;
      float r_std_dev;
      float r_std_err;
      
      get_distribution_stats(r_data, r_mean, r_median, r_upper, r_lower, r_max);
      r_std_dev = get_standard_deviation(r_data, r_mean);
      r_std_err = get_standard_error(r_data, r_std_dev);
      
      //Hilltop slope
      float s_mean;
      float s_median;
      float s_upper;
      float s_lower;
      float s_max;
      float s_std_dev;
      float s_std_err;
      
      get_distribution_stats(s_data, s_mean, s_median, s_upper, s_lower, s_max);
      s_std_dev = get_standard_deviation(s_data, s_mean);
      s_std_err = get_standard_error(s_data, s_std_dev);    
             
      //put patch stats into series of vectors ready to be written to file
      Final_ID.push_back(PatchID);
      
      lh_means.push_back(lh_mean);
      lh_medians.push_back(lh_median);
      lh_std_devs.push_back(lh_std_dev);
      lh_std_errs.push_back(lh_std_err);    
      
      cht_means.push_back(cht_mean);
      cht_medians.push_back(cht_median);
      cht_std_devs.push_back(cht_std_dev);
      cht_std_errs.push_back(cht_std_err);    
      
      r_means.push_back(r_mean);
      r_medians.push_back(r_median);
      r_std_devs.push_back(r_std_dev);
      r_std_errs.push_back(r_std_err);    
      
      s_means.push_back(s_mean);
      s_medians.push_back(s_median);
      s_std_devs.push_back(s_std_dev);
      s_std_errs.push_back(s_std_err);
      
    }
  }
  
  cout << "Writing patch data to file" << endl;
    
  //write the patch data  
  ofstream WritePatchData;                 
  stringstream ss;
  ss << path << prefix << "_E_R_Star_Patch_Data.csv";                
  WritePatchData.open(ss.str().c_str());

  //write the header file
  WritePatchData << "Final_ID,lh_means,lh_medians,lh_std_devs,lh_std_errs,cht_means,cht_medians,cht_std_devs,cht_std_errs,r_means,r_medians,r_std_devs,r_std_errs,s_means,s_medians,s_std_devs,s_std_errs" << endl;
  
  for (int w = 0; w < int(Final_ID.size());++w){
    //break this over a few lines for clarity
    WritePatchData << Final_ID[w] << "," << lh_means[w] << "," << lh_medians[w] << "," << lh_std_devs[w] << "," << lh_std_errs[w] << "," << cht_means[w] << "," << cht_medians[w] << "," << cht_std_devs[w] << "," << cht_std_errs[w] << "," << r_means[w] << "," << r_medians[w] << "," << r_std_devs[w] << "," << r_std_errs[w] << "," << s_means[w] << "," << s_medians[w] << "," << s_std_devs[w] << "," << s_std_errs[w] << endl;
   
  }
  
  WritePatchData.close();     

  //Now generate a raw data file so that the raw data can be plotted along with the segments
  
  cout << "Writing raw data to file" << endl;
  
  //write the raw data  
  ofstream WriteRawData;                 
  stringstream ss2;
  ss2 << path << prefix << "_E_R_Star_Raw_Data.csv";                
  WriteRawData.open(ss2.str().c_str());
    
  //write the header
  WriteRawData << "i,j,LH,CHT,Relief,Slope" << endl;  
    
   for (int i=0; i<nrows; ++i){
  	  for (int j=0; j<ncols; ++j){
  	  
  	    if (CHT.get_data_element(i,j) != ndv && LH.get_data_element(i,j) != ndv && Relief.get_data_element(i,j) != ndv && Slope.get_data_element(i,j) != ndv){
  	      	    
  	      WriteRawData << i << "," << j << "," << LH.get_data_element(i,j) << "," << CHT.get_data_element(i,j) << "," << Relief.get_data_element(i,j) << "," << Slope.get_data_element(i,j) << endl;
  	    
  	    }
  	  }  	  
  	}
    
  WriteRawData.close();
  
  //Now generate basin average data for the basins of the user supplied order
  
  cout << "Generating basin average data using LSDBasin" << endl;
  
  //create lsdbasin objects in a loop over each junction number
  vector< LSDBasin > Basins;
  
   //loop over each basin, generating an LSDBasin object which contains that basin's measurements
  for (int w = 0; w < int(basin_junctions.size()); ++w){
                                    
    LSDBasin Basin(basin_junctions[w], FlowInfo, JunctionNetwork);
    Basin.set_HillslopeLength_HFR(FlowInfo, LH);
    Basin.set_SlopeMean(FlowInfo, HilltopSlope);   
    Basin.set_ReliefMean(FlowInfo, Relief);
    Basin.set_CHTMean(FlowInfo, CHT);
    Basin.set_HilltopPx(FlowInfo,CHT);
  
    Basins.push_back(Basin);
                             
  }
  
  cout << "Writing basin average data to file" << endl;
  
  //write the basin data  
  ofstream WriteBasinData;                 
  stringstream ss3;
  ss3 << path << prefix << "_E_R_Star_Basin_" << BasinOrder << "_Data.csv";                
  WriteBasinData.open(ss3.str().c_str());
    
  //write the header
  WriteBasinData << "Basin_ID,LH,CHT,Relief,Slope,Area,Count" << endl;
  
  
  //write all data to the opened file, ensuring that there are data points to be written in each basin                                         
  for (int q = 0; q < int(Basins.size()); ++q){
    // only work where we have data points  - all data is templated from LH or CHT, so if these have data, all rasters have data
    if (Basins[q].CalculateNumDataPoints(FlowInfo, LH) != 0 && Basins[q].CalculateNumDataPoints(FlowInfo, CHT) != 0 ){
      
      WriteBasinData << Basins[q].get_Junction() << "," << Basins[q].get_HillslopeLength_HFR() << ",";
      WriteBasinData << Basins[q].get_CHTMean() << "," << Basins[q].get_ReliefMean() << ",";
      WriteBasinData << Basins[q].get_SlopeMean() << "," << Basins[q].get_Area() << ",";
      WriteBasinData << Basins[q].get_HilltopPx() << endl;
   
    }
  }
  
  WriteBasinData.close();
  
  //write the Patch raster data
  HilltopPatches.write_raster((path+prefix+"_Patches"),"flt");
  
}
