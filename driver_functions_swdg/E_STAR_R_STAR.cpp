//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// 
// E_STAR_R_STAR.cpp
// 
//
//  ONE THING TO CONSIDER IS WHETHER A PIXEL WITH A SLOPE > 0.4 SHOULD BE INCLUDED IN THE AVERAGES
// FOR A PATCH. CURRENTLY WE GET THE MEAN PATCH GRADIENT AND WOULD FILTER BASED ON THAT BUT IT MIGHT 
// BE WORTH EXPLORING THE DIFFERENCES IN RESULTS THAT EXCLUDING ALL PX WITH A SLOPE ABOVE THE THRESHOLD 
// FROM THE AVERAGING WILL HAVE ON THE RESULTS
//
// ALSO SHOULD LOOK INTO AN OPTIONAL EXTRA PARAM TO ALLOW HURST ET AL 2013 DBPR FILTERING TO BE PERFORMED.
// NEED TO THINK ABOUT HOW TO DO THIS IN A USER FRIENDLY WAY THOUGH.   
//
//
// Simple driver which takes the LH, Relief and CHT files generated by LH_Driver
// and averages the data by hilltop patch.
//
// Rest of this header will be written soon.
//
// Stuart W.D. Grieve
// University of Edinburgh
//
//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
#include <iostream>
#include <string>
#include <vector>
#include <fstream>
#include "../LSDStatsTools.hpp"
#include "../LSDRaster.hpp"
#include "../LSDIndexRaster.hpp"
#include "../LSDFlowInfo.hpp"
#include "../LSDChannel.hpp"
#include "../LSDJunctionNetwork.hpp"
#include "../LSDIndexChannel.hpp"
#include "../LSDMostLikelyPartitionsFinder.hpp"
#include "../LSDBasin.hpp"
#include "../LSDShapeTools.hpp"

int main ()
{
  
  //input arguments
  string path = "/home/s0675405/DataStore/CR/";
  string prefix = "CR2";
  //float slope_threshold = 0.4; //gradient at which cht no longer linearly scales with erosion rate shoudl equal 0.4 (Hurst et al., 2012)
  int MinimumPatchArea = 20; //Minium area of a hilltop patch. In pixels.

  cout << "Loading raster datasets" << endl;

  //Load data generated by LH_Driver.cpp

  //load hillslope length data
  LSDRaster LH((path+prefix+"_HFR_LH"), "flt"); 
  
  //load Relief
  LSDRaster Relief((path+prefix+"_Relief"), "flt");
  
  //load hilltop curvature
  LSDRaster CHT((path+prefix+"_CHT"), "flt");
  
  //load slope
  LSDRaster Slope((path+prefix+"_Slope"), "flt");
  
  cout << "Generating contiguous hilltop patches" << endl;
  
  //Run the hilltop patch algorithm
  LSDIndexRaster HilltopPatches = CHT.CreateHilltopPatches(MinimumPatchArea);
    
  float ndv = LH.get_NoDataValue();
  int nrows = LH.get_NRows();
  int ncols = LH.get_NCols();

  //set up some variables to store values as we run through the patches
  int PatchID;
  vector<float> lh_data;
  vector<float> cht_data;
  vector<float> r_data;
  vector<float> s_data;

  //vectors to store the stats for each patch
  vector<float> Final_ID;

  vector<float> lh_means;
  vector<float> lh_medians;
  vector<float> lh_std_devs;
  vector<float> lh_std_errs;    
  
  vector<float> cht_means;
  vector<float> cht_medians;
  vector<float> cht_std_devs;
  vector<float> cht_std_errs;    
  
  vector<float> r_means;
  vector<float> r_medians;
  vector<float> r_std_devs;
  vector<float> r_std_errs;    
  
  vector<float> s_means;
  vector<float> s_medians;
  vector<float> s_std_devs;
  vector<float> s_std_errs;

  //Get vector of unique segment indexes
  vector<int> PatchIndex = Unique(HilltopPatches.get_RasterData(), ndv);

  //for each patch in the landscape get the mean values
  for (int q = 0; q < int(PatchIndex.size()); ++q){
  
    PatchID = PatchIndex[q];
    
    //empty data vectors ready for next patch data to be added  
    lh_data.clear();
    cht_data.clear();
    r_data.clear();
    s_data.clear();
    
    for (int i=0; i<nrows; ++i){
  	  for (int j=0; j<ncols; ++j){
  	  
        if (HilltopPatches.get_data_element(i,j) == PatchID){
        
          //make sure we have valid data for each of our arrays
        	if (CHT.get_data_element(i,j) != ndv && LH.get_data_element(i,j) != ndv && Relief.get_data_element(i,j) != ndv && Slope.get_data_element(i,j) != ndv){
        	
              lh_data.push_back(LH.get_data_element(i,j));
              r_data.push_back(Relief.get_data_element(i,j));
              cht_data.push_back(CHT.get_data_element(i,j));
              s_data.push_back(Slope.get_data_element(i,j));              
              
            }
          }
        }
      }
  	
    //calculate the mean, median, stddev and std err values for each value in the current segment
  
    //Hillslope Length
    float lh_mean;
    float lh_median;
    float lh_upper;
    float lh_lower;
    float lh_max;
    float lh_std_dev;
    float lh_std_err;
  
    get_distribution_stats(lh_data, lh_mean, lh_median, lh_upper, lh_lower, lh_max);
    lh_std_dev = get_standard_deviation(lh_data, lh_mean);
    lh_std_err = get_standard_error(lh_data, lh_std_dev);
    
    //Hilltop Curvature
    float cht_mean;
    float cht_median;
    float cht_upper;
    float cht_lower;
    float cht_max;
    float cht_std_dev;
    float cht_std_err;
  
    get_distribution_stats(cht_data, cht_mean, cht_median, cht_upper, cht_lower, cht_max);
    cht_std_dev = get_standard_deviation(cht_data, cht_mean);
    cht_std_err = get_standard_error(cht_data, cht_std_dev);
    
    //Relief
    float r_mean;
    float r_median;
    float r_upper;
    float r_lower;
    float r_max;
    float r_std_dev;
    float r_std_err;
  
    get_distribution_stats(r_data, r_mean, r_median, r_upper, r_lower, r_max);
    r_std_dev = get_standard_deviation(r_data, r_mean);
    r_std_err = get_standard_error(r_data, r_std_dev);
    
    //Hilltop slope
    float s_mean;
    float s_median;
    float s_upper;
    float s_lower;
    float s_max;
    float s_std_dev;
    float s_std_err;
  
    get_distribution_stats(s_data, s_mean, s_median, s_upper, s_lower, s_max);
    s_std_dev = get_standard_deviation(s_data, s_mean);
    s_std_err = get_standard_error(s_data, s_std_dev);    
           
    //put patch stats into series of vectors ready to be written to file
    Final_ID.push_back(PatchID);
    
    lh_means.push_back(lh_mean);
    lh_medians.push_back(lh_median);
    lh_std_devs.push_back(lh_std_dev);
    lh_std_errs.push_back(lh_std_err);    
    
    cht_means.push_back(cht_mean);
    cht_medians.push_back(cht_median);
    cht_std_devs.push_back(cht_std_dev);
    cht_std_errs.push_back(cht_std_err);    
    
    r_means.push_back(r_mean);
    r_medians.push_back(r_median);
    r_std_devs.push_back(r_std_dev);
    r_std_errs.push_back(r_std_err);    
    
    s_means.push_back(s_mean);
    s_medians.push_back(s_median);
    s_std_devs.push_back(s_std_dev);
    s_std_errs.push_back(s_std_err);
    
    }
    
  
  
  
  //write the patch data  
  ofstream WritePatchData;                 
  stringstream ss;
  ss << path << prefix << "_E_R_Star_Patch_Data.csv";                
  WritePatchData.open(ss.str().c_str());
  
  for (int w = 0; w < int(Final_ID.size());++w){
  
    WritePatchData << Final_ID[w] << "," << lh_means[w] << "," << lh_medians[w] << "," << lh_std_devs[w] << "," << lh_std_errs[w] << "," << cht_means[w] << "," << cht_medians[w] << "," << cht_std_devs[w] << "," << cht_std_errs[w] << "," << r_means[w] << "," << r_medians[w] << "," << r_std_devs[w] << "," << r_std_errs[w] << "," << s_means[w] << "," << s_medians[w] << "," << s_std_devs[w] << "," << s_std_errs[w] << endl;
   
  }
  
  WritePatchData.close();

  //Now generate a raw data file so that the data cloud can be plotted along with the segments
  
  //write the patch data  
  ofstream WriteRawData;                 
  stringstream ss2;
  ss2 << path << prefix << "_E_R_Star_Raw_Data.csv";                
  WritePatchData.open(ss2.str().c_str());
    
   for (int i=0; i<nrows; ++i){
  	  for (int j=0; j<ncols; ++j){
  	  
  	    if (CHT.get_data_element(i,j) != ndv && LH.get_data_element(i,j) != ndv && Relief.get_data_element(i,j) != ndv && Slope.get_data_element(i,j) != ndv){
  	    
  	      WriteRawData << i << "," << j << "," << LH.get_data_element(i,j) << "," << CHT.get_data_element(i,j) << "," << Relief.get_data_element(i,j) << "," << Slope.get_data_element(i,j) << endl;
  	    
  	    }
  	  }  	  
  	}
    
  WritePatchData.close();
  
}
